<h1 id="ë°±ì¤€-ê³¨ë“œ3-ë§ì´-ë˜ê³ í”ˆ-ì›ìˆ­ì´">ë°±ì¤€ ê³¨ë“œ3 ë§ì´ ë˜ê³ í”ˆ ì›ìˆ­ì´</h1>
<p><a href="https://www.acmicpc.net/problem/1600">https://www.acmicpc.net/problem/1600</a></p>
<h2 id="ë¬¸ì œ">ë¬¸ì œ</h2>
<p><img alt="" src="https://velog.velcdn.com/images/jhh0830/post/c3f6bc33-4628-4755-9087-2579c367c1f8/image.png" /></p>
<h2 id="í’€ì´">í’€ì´</h2>
<p>ê°€ì¤‘ì¹˜ ì—†ëŠ” ìµœë‹¨ ê±°ë¦¬ = bfs
bfsë¡œ ë¬¸ì œë¥¼ í’€ì–´ë‚˜ê°”ë‹¤.</p>
<p>ë§ì˜ ê±¸ìŒì— ê´€í•œ ì¢Œí‘œë¥¼ dx, dyë¡œ ì €ì¥í–ˆê³ , ì›ìˆ­ì´ì— ëŒ€í•œ ì¢Œí‘œë¥¼ nx, nyë¡œ ì €ì¥í–ˆë‹¤.
íì—ëŠ” x, y ì¢Œí‘œì™€ ì´ ê±¸ìŒ, ë§ì˜ ê±¸ìŒ íšŸìˆ˜ë¥¼ ì €ì¥í–ˆë‹¤.
ê·¸ë ‡ê²Œ ë§ì˜ ê±¸ìŒì´ Kê°€ ë˜ë©´ ë”ì´ìƒ ë§ì˜ ê±¸ìŒì„ ì‚¬ìš©í•˜ì§€ ëª»í•˜ê²Œ í–ˆë‹¤.</p>
<p>ë¬¸ì œ ì•ˆ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë„ ì˜ ë‚˜ì™€ì„œ í˜¼ì ì˜ í‘¼ ì¤„ ì•Œì•˜ë‹¤...!</p>
<p>(ì•„ë˜ ì½”ë“œì—ì„œ ë§ì˜ ì¢Œí‘œ(dx, dy)ê°€ 8ê°œê°€ ì•„ë‹Œ ì´ìœ ëŠ” ë§¨ ì™¼ìª½ ìƒë‹¨ë¶€ë¶„ì€ ëª©í‘œê°€ ì˜¤ë¥¸ìª½ ì•„ë˜ë°©í–¥ì´ë¼ í•„ìš” ì—†ì„ê±°ë¼ ìƒê°í–ˆì—ˆë‹¤ 
-&gt; í•˜ì§€ë§Œ ìˆëŠ” ë°©í–¥ ë‹¤ ì¨ì•¼ ëë‚˜ë´„. ì´ê±° í•˜ë‚˜ë¡œ ì‹œê°„ì´ˆê³¼ ë‚˜ì§€ë„ ì•Šê³  bfsì¸ ì´ìƒ ê´œì°®ì€ ê²ƒ ê°™ë‹¤.)</p>
<p>í•˜ì§€ë§Œ <strong>&quot;í‹€ë ¸ìŠµë‹ˆë‹¤&quot;</strong></p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
    static int K, W, H, cnt = 0, count=0;
    static int[][] arr;
    static boolean[][] visit;
    static int dx[] = { 2, 1, 2, 1, -2, -1};
    static int dy[] = { 1, 2, -1, -2, 1, 2};
    static int nx[] = { 1, -1, 0, 0};
    static int ny[] = { 0, 0, -1, 1};
    static boolean flag;


    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        K = Integer.parseInt(bufferedReader.readLine());

        StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
        W = Integer.parseInt(stringTokenizer.nextToken());
        H = Integer.parseInt(stringTokenizer.nextToken());

        arr = new int[H][W];
        visit = new boolean[H][W];

        for(int i=0;i&lt;H;i++){
            stringTokenizer = new StringTokenizer(bufferedReader.readLine());
            for(int j=0;j&lt;W;j++){
                arr[i][j] = Integer.parseInt(stringTokenizer.nextToken());
            }
        }

        bfs(0,0);

        if(!flag){
            System.out.println(cnt);
        } else{
            System.out.println(-1);
        }
    }

    static void bfs(int x, int y){
        Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();
        queue.offer(new Node(x, y, 0, 0));

        while(!queue.isEmpty()){
            Node node = queue.poll();

            if(node.horse &lt; K) {
                for (int i = 0; i &lt; 6; i++) {
                    int new_x = node.x + dx[i];
                    int new_y = node.y + dy[i];

                    if (check(new_x, new_y)) {
                        if (new_x == W-1 &amp;&amp; new_y == H-1) {
                            cnt = node.c + 1;
                            return;
                        }
                        count++;
                        queue.offer(new Node(new_x, new_y, node.c + 1, node.horse + 1));
                        visit[new_y][new_x] = true;
                    }
                }
            }
            for(int i=0;i&lt;4;i++){
                int new_x = node.x + nx[i];
                int new_y = node.y + ny[i];

                if(check(new_x, new_y)){
                    if(new_x == W-1 &amp;&amp; new_y == H-1){
                        cnt = node.c + 1;
                        return;
                    }

                    queue.offer(new Node(new_x, new_y, node.c+1, node.horse));
                    visit[new_y][new_x] = true;
                }
            }
        }
        flag = true;
    }

    static boolean check(int x, int y){
        if(x &lt; 0 || y &lt; 0 || x &gt;= W || y &gt;= H || visit[y][x] || arr[y][x] == 1){
            return false;
        }
        return true;
    }

    static class Node{
        int x, y, c, horse;
        Node(int x, int y, int c, int horse){
            this.x=x;
            this.y=y;
            this.c=c;
            this.horse=horse;
        }
    }
}</code></pre>
<h2 id="2ë²ˆì§¸-í’€ì´">2ë²ˆì§¸ í’€ì´</h2>
<p>ì´ ë¬¸ì œëŠ” visit ì²˜ë¦¬ë¥¼ ë” ì‹ ì¤‘í•˜ê²Œ í–ˆì–´ì•¼ í–ˆë‹¤.
ì´ë¯¸ ë°©ë¬¸í–ˆì–´ë„ ë§ì˜ ê±¸ìŒìœ¼ë¡œ ë°©ë¬¸í•  ìˆ˜ë„, ì›ìˆ­ì´ì˜ ê±¸ìŒìœ¼ë¡œ ë°©ë¬¸í•  ìˆ˜ë„ ìˆê¸° ë•Œë¬¸ì´ë‹¤.
ì´ë ‡ê²Œ <strong>ë°©ë¬¸í•˜ëŠ” ê²½ìš°ì— ë”°ë¼ ì²˜ë¦¬ë¥¼ ë‹¤ë¥´ê²Œ í•´ì•¼ í•  ê²½ìš° visitë¥¼ 3ì°¨ì› ë°°ì—´ë¡œ ì„ ì–¸</strong>í•´ì•¼ í•œë‹¤.
ë§ì˜ ê±¸ìŒì¼ ê²½ìš°ì—ë„ ì–´ë–»ê²Œ ì‹œì‘í•œ ë§ì˜ ê±¸ìŒì¸ì§€? êµ¬ë¶„í•˜ê¸° ìœ„í•´ ë§ì˜ ê±¸ìŒì¼ ê²½ìš° 
visit[x][y][node.horse+1]ì„ í•˜ê³  ì›ìˆ­ì´ëŠ” visit[x][y][node.horse]ë¥¼ í•˜ì˜€ë‹¤.</p>
<p> í•˜ì§€ë§Œ &quot;ë©”ëª¨ë¦¬ ì´ˆê³¼&quot;</p>
<blockquote>
<p>ê·¼ë° ê¸€ ì ìœ¼ë©´ì„œ í—·ê°ˆë¦¬ëŠ”ê±°... 
!visit[new_y][new_x][node.horse]ì— ëŒ€í•´ ë°©ë¬¸ ì²˜ë¦¬ í•˜ê³  
visit[new_y][new_x][node.horse+1] = true; 
ì´ê±¸ ë°©ë¬¸ ì²˜ë¦¬ í•˜ì§€?
-&gt; ì‹¶ì—ˆì§€ë§Œ ì´ê²Œ ë¬¸ì œì˜€ë„¤ ğŸ˜‚</p>
</blockquote>
<pre><code class="language-java">for (int i = 0; i &lt; 8; i++) {
                    int new_x = node.x + dx[i];
                    int new_y = node.y + dy[i];
                    if (check(new_x, new_y)) {
                        if (new_x == W-1 &amp;&amp; new_y == H-1) {
                            cnt = node.c + 1;
                            return;
                        }
                        if(!visit[new_y][new_x][node.horse]) {
                            queue.offer(new Node(new_x, new_y, node.c + 1, node.horse + 1));
                            visit[new_y][new_x][node.horse+1] = true;
                        }
                    }
                }
          }
     }
 }             </code></pre>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
    static int K, W, H, cnt = 0;
    static int[][] arr;
    static boolean[][][] visit;
    static int dx[] = { 2, 1, 2, 1, -2, -1, -2, -1};
    static int dy[] = { 1, 2, -1, -2, 1, 2, -1, -2};
    static int nx[] = { 1, -1, 0, 0};
    static int ny[] = { 0, 0, -1, 1};
    static boolean flag;


    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        K = Integer.parseInt(bufferedReader.readLine());

        StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
        W = Integer.parseInt(stringTokenizer.nextToken());
        H = Integer.parseInt(stringTokenizer.nextToken());

        arr = new int[H][W];
        visit = new boolean[H][W][31];

        for(int i=0;i&lt;H;i++){
            stringTokenizer = new StringTokenizer(bufferedReader.readLine());
            for(int j=0;j&lt;W;j++){
                arr[i][j] = Integer.parseInt(stringTokenizer.nextToken());
            }
        }

        bfs(0,0);

        if(!flag){
            System.out.println(cnt);
        } else{
            System.out.println(-1);
        }
    }

    static void bfs(int x, int y){
        Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();
        queue.offer(new Node(x, y, 0, 0));
        visit[y][x][0] = true;

        while(!queue.isEmpty()){
            Node node = queue.poll();

            if(node.horse &lt; K) {
                for (int i = 0; i &lt; 8; i++) {
                    int new_x = node.x + dx[i];
                    int new_y = node.y + dy[i];

                    if (check(new_x, new_y)) {
                        if (new_x == W-1 &amp;&amp; new_y == H-1) {
                            cnt = node.c + 1;
                            return;
                        }
                        if(!visit[new_y][new_x][node.horse]) {
                            queue.offer(new Node(new_x, new_y, node.c + 1, node.horse + 1));
                            visit[new_y][new_x][node.horse+1] = true;
                        }
                    }
                }
            }
            for(int i=0;i&lt;4;i++){
                int new_x = node.x + nx[i];
                int new_y = node.y + ny[i];

                if(check(new_x, new_y)){
                    if(new_x == W-1 &amp;&amp; new_y == H-1){
                        cnt = node.c + 1;
                        return;
                    }
                    if(!visit[new_y][new_x][node.horse]) {
                        queue.offer(new Node(new_x, new_y, node.c + 1, node.horse));
                        visit[new_y][new_x][node.horse] = true;
                    }
                }
            }
        }
        flag = true;
    }

    static boolean check(int x, int y){
        if(x &lt; 0 || y &lt; 0 || x &gt;= W || y &gt;= H || arr[y][x] == 1){
            return false;
        }
        return true;
    }

    static class Node{
        int x, y, c, horse;
        Node(int x, int y, int c, int horse){
            this.x=x;
            this.y=y;
            this.c=c;
            this.horse=horse;
        }
    }
}</code></pre>
<p>ë„¤... ìœ„ì— ì ì€ ë¶€ë¶„</p>
<blockquote>
<p>!visit[new_y][new_x][node.horse]ì— ëŒ€í•´ ë°©ë¬¸ ì²˜ë¦¬ í•˜ê³  
visit[new_y][new_x][node.horse+1] = true; </p>
</blockquote>
<p>ì´ê²Œ ë¬¸ì œ ì˜€ì–´ìš”.
ì™œëƒë©´ ìƒˆë¡œìš´ ì¢Œí‘œì— ëŒ€í•œ visitë¥¼ íŒë‹¨í•˜ëŠ”ê±°ë‹ˆê¹Œ ìƒˆë¡œìš´ node.horseë„ í–ˆì–´ì•¼ì£  ã… </p>
<p>ê·¸ë˜ë„ ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ìë£Œêµ¬ì¡° ë§ì´ ì¨ì„œ ë‚˜ì˜¤ëŠ”ê±´ ì¤„ë§Œ ì•Œì•˜ëŠ”ë° ëŸ­í‚¤ë¹„í‚¤ì˜ˆìš” ;)
ìë£Œêµ¬ì¡° ë­ ì§€ì›Œì•¼ í•˜ëŠ”ê±´ê°€? ì‹¶ì—ˆê±°ë“ ìš”
<br /></p>
<p>ì´ê±° í•´ê²°í•˜ë‹ˆê¹Œ ì„±ê³µí–ˆì„ê¹Œìš”?</p>
<p>96%ì¯¤ì¸ê°€ <strong>&quot;í‹€ë ¸ìŠµë‹ˆë‹¤.&quot;</strong>
(ì§„ì§œ ë§ì„ ì¤„ ì•Œê³  ëë‚¬ë‹¤ í•˜ê³  ì¼ì–´ë‚¬ì—ˆëŠ”ë° ã… -ã… )</p>
<h3 id="3ë²ˆì§¸-í’€ì´">3ë²ˆì§¸ í’€ì´</h3>
<p>ë¬¸ì œë¥¼ ì˜ ë³´ë©´ ì¢Œí‘œê°€ 1,1ì¼ìˆ˜ë„ ìˆì–´ìš”.
í•˜ì§€ë§Œ 1,1ì€ ê°ˆ ìˆ˜ ìˆëŠ” ì¢Œí‘œê°€ ì—†ì–´ì„œ ë¬´ì‚¬íˆ whileë¬¸ì„ ë¹ ì ¸ë‚˜ì™€ flagê°€ trueê°€ ëì£ .
ê·¸ë˜ì„œ ì˜ˆì™¸ë¡œ 1,1ì¼ ê²½ìš°, ì¦‰ <strong>ì¶œë°œì§€ì™€ ëª©ì ì§€ê°€ ê°™ì„ ê²½ìš° 0ìœ¼ë¡œ ì²˜ë¦¬</strong>ë˜ê²Œ í•´ì£¼ì—ˆì–´ìš”.</p>
<p>ê·¸ë ‡ê²Œ <strong>ì„±ê³µ!!!</strong></p>
<pre><code class="language-java">import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
    static int K, W, H, cnt = 0;
    static int[][] arr;
    static boolean[][][] visit;
    static int dx[] = { 2, 1, 2, 1, -2, -1, -2, -1};
    static int dy[] = { 1, 2, -1, -2, 1, 2, -1, -2};
    static int nx[] = { 1, -1, 0, 0};
    static int ny[] = { 0, 0, -1, 1};
    static boolean flag;


    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        K = Integer.parseInt(bufferedReader.readLine());

        StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
        W = Integer.parseInt(stringTokenizer.nextToken());
        H = Integer.parseInt(stringTokenizer.nextToken());

        arr = new int[H][W];
        visit = new boolean[H][W][31];

        for(int i=0;i&lt;H;i++){
            stringTokenizer = new StringTokenizer(bufferedReader.readLine());
            for(int j=0;j&lt;W;j++){
                arr[i][j] = Integer.parseInt(stringTokenizer.nextToken());
            }
        }

        if(H==1 &amp;&amp; W==1) {
            cnt = 0;
        } else {
            bfs(0, 0);
        }

        if(!flag){
            System.out.println(cnt);
        } else{
            System.out.println(-1);
        }
    }

    static void bfs(int x, int y){
        Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();
        queue.offer(new Node(x, y, 0, 0));
        visit[y][x][0] = true;

        while(!queue.isEmpty()){
            Node node = queue.poll();

            if(node.horse &lt; K) {
                for (int i = 0; i &lt; 8; i++) {
                    int new_x = node.x + dx[i];
                    int new_y = node.y + dy[i];

                    if (check(new_x, new_y)) {
                        if (new_x == W-1 &amp;&amp; new_y == H-1) {
                            cnt = node.c + 1;
                            return;
                        }
                        if(!visit[new_y][new_x][node.horse + 1]) {
                            queue.offer(new Node(new_x, new_y, node.c + 1, node.horse + 1));
                            visit[new_y][new_x][node.horse + 1] = true;
                        }
                    }
                }
            }
            for(int i=0;i&lt;4;i++){
                int new_x = node.x + nx[i];
                int new_y = node.y + ny[i];

                if(check(new_x, new_y)){
                    if(new_x == W-1 &amp;&amp; new_y == H-1){
                        cnt = node.c + 1;
                        return;
                    }
                    if(!visit[new_y][new_x][node.horse]) {
                        queue.offer(new Node(new_x, new_y, node.c + 1, node.horse));
                        visit[new_y][new_x][node.horse] = true;
                    }
                }
            }
        }
        flag = true;
    }

    static boolean check(int x, int y){
        if(x &lt; 0 || y &lt; 0 || x &gt;= W || y &gt;= H || arr[y][x] == 1){
            return false;
        }
        return true;
    }

    static class Node{
        int x, y, c, horse;
        Node(int x, int y, int c, int horse){
            this.x=x;
            this.y=y;
            this.c=c;
            this.horse=horse;
        }
    }
}</code></pre>
<hr />
<h2 id="ìš”ì•½">ìš”ì•½</h2>
<ul>
<li>ë°©ë¬¸ ì²˜ë¦¬í•  ë•Œ ê²½ìš°ì— ë”°ë¼ ë°©ë¬¸ ì²˜ë¦¬ë¥¼ ë‹¤ë¥´ê²Œ í•´ì£¼ì–´ì•¼ í•  ê²½ìš° 3ì°¨ì› visit ë°°ì—´ ì“°ê¸°</li>
<li>ë¬¸ì œ ì˜ ì½ê¸°. ì˜ˆì™¸ê°€ ìˆì„ì§€ í™•ì¸í•˜ê¸° (ex. (1,1) ì¢Œí‘œ ë“±)</li>
</ul>